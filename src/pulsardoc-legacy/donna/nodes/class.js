// Generated by CoffeeScript 1.10.0
(function() {
  var Class, Doc, Method, Node, Property, Variable, VirtualMethod, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Node = require('./node');

  Method = require('./method');

  VirtualMethod = require('./virtual_method');

  Variable = require('./variable');

  Property = require('./property');

  Doc = require('./doc');

  _ = require('underscore');

  module.exports = Class = (function(superClass) {
    extend(Class, superClass);

    function Class(node, fileName, lineMapping, options, comment) {
      var doc, error, error1, exp, i, j, k, len, len1, len2, method, name, previousExp, previousProp, prop, property, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, swallowedDoc, type, variable;
      this.node = node;
      this.fileName = fileName;
      this.lineMapping = lineMapping;
      this.options = options;
      try {
        this.methods = [];
        this.variables = [];
        this.properties = [];
        this.doc = new Doc(comment, this.options);
        if (this.doc.methods) {
          ref1 = (ref = this.doc) != null ? ref.methods : void 0;
          for (i = 0, len = ref1.length; i < len; i++) {
            method = ref1[i];
            this.methods.push(new VirtualMethod(this, method, this.lineMapping, this.options));
          }
        }
        previousExp = null;
        ref2 = this.node.body.expressions;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          exp = ref2[j];
          switch (exp.constructor.name) {
            case 'Assign':
              if ((previousExp != null ? previousExp.constructor.name : void 0) === 'Comment') {
                doc = previousExp;
              }
              doc || (doc = swallowedDoc);
              switch ((ref3 = exp.value) != null ? ref3.constructor.name : void 0) {
                case 'Code':
                  if (exp.variable.base.value === 'this') {
                    this.methods.push(new Method(this, exp, this.lineMapping, this.options, doc));
                  }
                  break;
                case 'Value':
                  this.variables.push(new Variable(this, exp, this.lineMapping, this.options, true, doc));
              }
              doc = null;
              break;
            case 'Value':
              previousProp = null;
              ref4 = exp.base.properties;
              for (k = 0, len2 = ref4.length; k < len2; k++) {
                prop = ref4[k];
                if ((previousProp != null ? previousProp.constructor.name : void 0) === 'Comment') {
                  doc = previousProp;
                }
                doc || (doc = swallowedDoc);
                switch ((ref5 = prop.value) != null ? ref5.constructor.name : void 0) {
                  case 'Code':
                    this.methods.push(new Method(this, prop, this.lineMapping, this.options, doc));
                    break;
                  case 'Value':
                    variable = new Variable(this, prop, this.lineMapping, this.options, false, doc);
                    if ((ref6 = variable.doc) != null ? ref6.property : void 0) {
                      property = new Property(this, prop, this.lineMapping, this.options, variable.getName(), doc);
                      property.setter = true;
                      property.getter = true;
                      this.properties.push(property);
                    } else {
                      this.variables.push(variable);
                    }
                }
                doc = null;
                previousProp = prop;
              }
              break;
            case 'Call':
              if ((previousExp != null ? previousExp.constructor.name : void 0) === 'Comment') {
                doc = previousExp;
              }
              doc || (doc = swallowedDoc);
              type = (ref7 = exp.variable) != null ? (ref8 = ref7.base) != null ? ref8.value : void 0 : void 0;
              name = (ref9 = exp.args) != null ? (ref10 = ref9[0]) != null ? (ref11 = ref10.base) != null ? (ref12 = ref11.properties) != null ? (ref13 = ref12[0]) != null ? (ref14 = ref13.variable) != null ? (ref15 = ref14.base) != null ? ref15.value : void 0 : void 0 : void 0 : void 0 : void 0 : void 0 : void 0;
              swallowedDoc = (ref16 = exp.args) != null ? (ref17 = ref16[0]) != null ? (ref18 = ref17.base) != null ? (ref19 = ref18.properties) != null ? ref19[1] : void 0 : void 0 : void 0 : void 0;
              if (name && (type === 'set' || type === 'get')) {
                property = _.find(this.properties, function(p) {
                  return p.name === name;
                });
                if (!property) {
                  property = new Property(this, exp, this.smc, this.options, name, doc);
                  this.properties.push(property);
                }
                if (type === 'set') {
                  property.setter = true;
                }
                if (type === 'get') {
                  property.getter = true;
                }
                doc = null;
              }
          }
          previousExp = exp;
        }
      } catch (error1) {
        error = error1;
        if (this.options.verbose) {
          console.warn('Create class error:', this.node, error);
        }
      }
    }

    Class.prototype.getFileName = function() {
      return this.fileName;
    };

    Class.prototype.getDoc = function() {
      return this.doc;
    };

    Class.prototype.getFullName = function() {
      return this.getClassName();
    };

    Class.prototype.getClassName = function() {
      var error, error1, i, j, len, len1, outer, prop, ref, ref1;
      try {
        if (!(this.className || !this.node.variable)) {
          this.className = this.node.variable.base.value;
          if (this.className === 'this') {
            outer = this.findAncestor('Class');
            if (outer) {
              this.className = outer.variable.base.value;
              ref = outer.variable.properties;
              for (i = 0, len = ref.length; i < len; i++) {
                prop = ref[i];
                this.className += "." + prop.name.value;
              }
            } else {
              this.className = '';
            }
          }
          ref1 = this.node.variable.properties;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            prop = ref1[j];
            this.className += "." + prop.name.value;
          }
        }
        return this.className;
      } catch (error1) {
        error = error1;
        if (this.options.verbose) {
          return console.warn("Get class classname error at " + this.fileName + ":", this.node, error);
        }
      }
    };

    Class.prototype.getName = function() {
      var error, error1;
      try {
        if (!this.name) {
          this.name = this.getClassName().split('.').pop();
        }
        return this.name;
      } catch (error1) {
        error = error1;
        if (this.options.verbose) {
          return console.warn("Get class name error at " + this.fileName + ":", this.node, error);
        }
      }
    };

    Class.prototype.getLocation = function() {
      var error, error1, firstLine, locationData;
      try {
        if (!this.location) {
          locationData = this.node.variable.locationData;
          firstLine = locationData.first_line + 1;
          if (this.lineMapping[firstLine] == null) {
            this.lineMapping[firstLine] = this.lineMapping[firstLine - 1];
          }
          this.location = {
            line: this.lineMapping[firstLine]
          };
        }
        return this.location;
      } catch (error1) {
        error = error1;
        if (this.options.verbose) {
          return console.warn("Get location error at " + this.fileName + ":", this.node, error);
        }
      }
    };

    Class.prototype.getNamespace = function() {
      var error, error1;
      try {
        if (!this.namespace) {
          this.namespace = this.getClassName().split('.');
          this.namespace.pop();
          this.namespace = this.namespace.join('.');
        }
        return this.namespace;
      } catch (error1) {
        error = error1;
        if (this.options.verbose) {
          return console.warn("Get class namespace error at " + this.fileName + ":", this.node, error);
        }
      }
    };

    Class.prototype.getParentClassName = function() {
      var error, error1, i, j, len, len1, outer, prop, ref, ref1;
      try {
        if (!this.parentClassName) {
          if (this.node.parent) {
            this.parentClassName = this.node.parent.base.value;
            if (this.parentClassName === 'this') {
              outer = this.findAncestor('Class');
              if (outer) {
                this.parentClassName = outer.parent.base.value;
                ref = outer.parent.properties;
                for (i = 0, len = ref.length; i < len; i++) {
                  prop = ref[i];
                  this.parentClassName += "." + prop.name.value;
                }
              } else {
                this.parentClassName = '';
              }
            }
            ref1 = this.node.parent.properties;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              prop = ref1[j];
              this.parentClassName += "." + prop.name.value;
            }
          }
        }
        return this.parentClassName;
      } catch (error1) {
        error = error1;
        if (this.options.verbose) {
          return console.warn("Get class parent classname error at " + this.fileName + ":", this.node, error);
        }
      }
    };

    Class.prototype.getMethods = function() {
      return this.methods;
    };

    Class.prototype.getVariables = function() {
      return this.variables;
    };

    return Class;

  })(Node);

}).call(this);
