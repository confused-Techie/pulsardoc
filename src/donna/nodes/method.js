// Generated by CoffeeScript 1.10.0
(function() {
  var Doc, Method, Node, Parameter, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Node = require('./node');

  Parameter = require('./parameter');

  Doc = require('./doc');

  _ = require('underscore');

  _.str = require('underscore.string');

  module.exports = Method = (function(superClass) {
    extend(Method, superClass);

    function Method(entity, node, lineMapping, options, comment) {
      var error, error1, j, k, len, len1, param, property, ref, ref1;
      this.entity = entity;
      this.node = node;
      this.lineMapping = lineMapping;
      this.options = options;
      try {
        this.parameters = [];
        this.doc = new Doc(comment, this.options);
        ref = this.node.value.params;
        for (j = 0, len = ref.length; j < len; j++) {
          param = ref[j];
          if ((param.name.properties != null) && (param.name.properties[0].base != null)) {
            ref1 = param.name.properties;
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              property = ref1[k];
              this.parameters.push(new Parameter(param, this.options, true));
            }
          } else {
            this.parameters.push(new Parameter(param, this.options));
          }
        }
        this.getName();
      } catch (error1) {
        error = error1;
        if (this.options.verbose) {
          console.warn('Create method error:', this.node, error);
        }
      }
    }

    Method.prototype.getType = function() {
      if (!this.type) {
        switch (this.entity.constructor.name) {
          case 'Class':
            this.type = 'instance';
            break;
          case 'Mixin':
            this.type = 'mixin';
            break;
          case 'File':
            this.type = 'file';
        }
      }
      return this.type;
    };

    Method.prototype.getOriginalFilename = function() {
      if (!this.originalFilename) {
        this.originalFilename = this.getDoc().originalFilename;
      }
      return this.originalFilename;
    };

    Method.prototype.getOriginalName = function() {
      if (!this.originalName) {
        this.originalName = this.getDoc().originalName;
      }
      return this.originalName;
    };

    Method.prototype.getOriginalType = function() {
      if (!this.originalType) {
        this.originalType = this.getDoc().originalType;
      }
      return this.originalType;
    };

    Method.prototype.getDoc = function() {
      return this.doc;
    };

    Method.prototype.getSignature = function() {
      var doc, error, error1, i, j, k, len, len1, optionizedDefaults, param, paramOptionized, paramValue, params, ref, ref1, retVal, retVals;
      try {
        if (!this.signature) {
          this.signature = (function() {
            switch (this.getType()) {
              case 'class':
                return '.';
              case 'instance':
                return '::';
              default:
                if (this.getOriginalFilename() != null) {
                  return "::";
                } else {
                  return '? ';
                }
            }
          }).call(this);
          doc = this.getDoc();
          if (doc.returnValue && doc.returnValue[0].type) {
            retVals = [];
            ref = doc.returnValue;
            for (j = 0, len = ref.length; j < len; j++) {
              retVal = ref[j];
              retVals.push("" + (_.str.escapeHTML(retVal.type)));
            }
            this.signature = retVals.join("|") + (" " + this.signature);
          }
          this.signature += "<strong>" + (this.getOriginalName() || this.getName()) + "</strong>";
          this.signature += '(';
          params = [];
          paramOptionized = [];
          ref1 = this.getParameters();
          for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
            param = ref1[i];
            if (param.optionized) {
              this.inParamOption = true;
              optionizedDefaults = param.getOptionizedDefaults();
              paramOptionized.push(param.getName(i));
            } else {
              if (this.inParamOption) {
                this.inParamOption = false;
                paramValue = "{" + (paramOptionized.join(', ')) + "}";
                if (optionizedDefaults) {
                  paramValue += "=" + optionizedDefaults;
                }
                params.push(paramValue);
                paramOptionized = [];
              } else {
                params.push(param.getSignature());
              }
            }
          }
          if (paramOptionized.length > 0) {
            paramValue = "{" + (paramOptionized.join(', ')) + "}";
            if (optionizedDefaults) {
              paramValue += "=" + optionizedDefaults;
            }
            params.push(paramValue);
          }
          this.signature += params.join(', ');
          this.signature += ')';
        }
        return this.signature;
      } catch (error1) {
        error = error1;
        if (this.options.verbose) {
          return console.warn('Get method signature error:', this.node, error);
        }
      }
    };

    Method.prototype.getShortSignature = function() {
      var error, error1;
      try {
        if (!this.shortSignature) {
          this.shortSignature = (function() {
            switch (this.getType()) {
              case 'class':
                return '@';
              case 'instance':
                return '.';
              default:
                return '';
            }
          }).call(this);
          this.shortSignature += this.getName();
        }
        return this.shortSignature;
      } catch (error1) {
        error = error1;
        if (this.options.verbose) {
          return console.warn('Get method short signature error:', this.node, error);
        }
      }
    };

    Method.prototype.getName = function() {
      var error, error1, j, len, prop, ref;
      try {
        if (!this.name) {
          this.name = this.node.variable.base.value;
          if (this.name.reserved === true) {
            this.name = this.name.slice(0);
          }
          ref = this.node.variable.properties;
          for (j = 0, len = ref.length; j < len; j++) {
            prop = ref[j];
            this.name += "." + prop.name.value;
          }
          if (/^this\./.test(this.name)) {
            this.name = this.name.substring(5);
            this.type = 'class';
          }
          if (/^module.exports\./.test(this.name)) {
            this.name = this.name.substring(15);
            this.type = 'class';
          }
          if (/^exports\./.test(this.name)) {
            this.name = this.name.substring(8);
            this.type = 'class';
          }
        }
        return this.name;
      } catch (error1) {
        error = error1;
        if (this.options.verbose) {
          return console.warn('Get method name error:', this.node, error);
        }
      }
    };

    Method.prototype.getLocation = function() {
      var error, error1, firstLine, locationData;
      try {
        if (!this.location) {
          locationData = this.node.variable.locationData;
          firstLine = locationData.first_line + 1;
          if (this.lineMapping[firstLine] == null) {
            this.lineMapping[firstLine] = this.lineMapping[firstLine - 1];
          }
          this.location = {
            line: this.lineMapping[firstLine]
          };
        }
        return this.location;
      } catch (error1) {
        error = error1;
        if (this.options.verbose) {
          return console.warn("Get location error at " + this.fileName + ":", this.node, error);
        }
      }
    };

    Method.prototype.getParameters = function() {
      return this.parameters;
    };

    return Method;

  })(Node);

}).call(this);
