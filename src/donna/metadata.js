// Generated by CoffeeScript 1.10.0
(function() {
  var Metadata, _, builtins, fs, path;

  fs = require('fs');

  path = require('path');

  _ = require('underscore');

  builtins = require('builtins');

  module.exports = Metadata = (function() {
    function Metadata(dependencies, parser) {
      this.dependencies = dependencies;
      this.parser = parser;
    }

    Metadata.prototype.generate = function(root) {
      this.root = root;
      this.defs = {};
      this.exports = {};
      this.bindingTypes = {};
      this.modules = {};
      this.classes = this.parser.classes;
      this.files = this.parser.files;
      return this.root.traverseChildren(false, (function(_this) {
        return function(exp) {
          return _this.visit(exp);
        };
      })(this));
    };

    Metadata.prototype.visit = function(exp) {
      var name1;
      return typeof this[name1 = "visit" + exp.constructor.name] === "function" ? this[name1](exp) : void 0;
    };

    Metadata.prototype["eval"] = function(exp) {
      return this["eval" + exp.constructor.name](exp);
    };

    Metadata.prototype.visitComment = function(exp) {
      if (exp.comment === '~Private~') {

      }
    };

    Metadata.prototype.visitClass = function(exp) {
      if (exp.variable == null) {
        return;
      }
      this.defs[exp.variable.base.value] = this.evalClass(exp);
      return false;
    };

    Metadata.prototype.visitAssign = function(exp) {
      var baseName, file, firstProp, i, j, k, key, keyPath, len, len1, len2, method, prop, ref1, ref2, ref3, ref4, ref5, ref6, results, value, variable;
      variable = this["eval"](exp.variable);
      value = this["eval"](exp.value);
      baseName = exp.variable.base.value;
      switch (baseName) {
        case 'module':
          if (exp.variable.properties.length === 0) {
            return;
          }
          if (((ref1 = exp.variable.properties) != null ? (ref2 = ref1[0]) != null ? (ref3 = ref2.name) != null ? ref3.value : void 0 : void 0 : void 0) !== 'exports') {
            throw new Error('BUG: Does not support module.somthingOtherThanExports');
          }
          baseName = 'exports';
          firstProp = exp.variable.properties[1];
          break;
        case 'exports':
          firstProp = exp.variable.properties[0];
      }
      switch (baseName) {
        case 'exports':
          if (firstProp) {
            if ((value.base != null) && this.defs[value.base.value]) {
              return this.exports[firstProp.name.value] = this.defs[value.base.value];
            } else {
              if (firstProp.name.value !== value.name) {
                this.defs[firstProp.name.value] = {
                  name: firstProp.name.value,
                  bindingType: 'exportsProperty',
                  type: value.type,
                  range: [[exp.variable.base.locationData.first_line, exp.variable.base.locationData.first_column], [exp.variable.base.locationData.last_line, exp.variable.base.locationData.last_column]]
                };
              }
              return this.exports[firstProp.name.value] = {
                startLineNumber: exp.variable.base.locationData.first_line
              };
            }
          } else {
            this.exports = {
              _default: value
            };
            switch (value.type) {
              case 'class':
                return this.bindingTypes[value.name] = "exports";
            }
          }
          break;
        default:
          switch (exp.variable.base.constructor.name) {
            case 'Literal':
              if (!(value != null ? value.range : void 0)) {
                return;
              }
              if (exp.variable.properties.length > 0) {
                keyPath = exp.variable.base.value;
                ref4 = exp.variable.properties;
                for (i = 0, len = ref4.length; i < len; i++) {
                  prop = ref4[i];
                  if (prop.name != null) {
                    keyPath += "." + prop.name.value;
                  } else {
                    keyPath += "[" + prop.index.base.value + "]";
                  }
                }
                return this.defs[keyPath] = _.extend({
                  name: keyPath
                }, value);
              } else {
                this.defs[exp.variable.base.value] = _.extend({
                  name: exp.variable.base.value
                }, value);
                if (this.defs[exp.variable.base.value].type === "import") {
                  key = this.defs[exp.variable.base.value].path || this.defs[exp.variable.base.value].module;
                  if (_.isUndefined(this.modules[key])) {
                    this.modules[key] = [];
                  }
                  this.modules[key].push({
                    name: this.defs[exp.variable.base.value].name,
                    range: this.defs[exp.variable.base.value].range
                  });
                }
                switch (this.defs[exp.variable.base.value].type) {
                  case 'function':
                    ref5 = this.files;
                    results = [];
                    for (j = 0, len1 = ref5.length; j < len1; j++) {
                      file = ref5[j];
                      results.push((function() {
                        var k, len2, ref6, results1;
                        ref6 = file.methods;
                        results1 = [];
                        for (k = 0, len2 = ref6.length; k < len2; k++) {
                          method = ref6[k];
                          if (this.defs[exp.variable.base.value].name === method.name) {
                            this.defs[exp.variable.base.value].doc = method.doc.comment;
                            break;
                          } else {
                            results1.push(void 0);
                          }
                        }
                        return results1;
                      }).call(this));
                    }
                    return results;
                }
              }
              break;
            case 'Obj':
            case 'Arr':
              ref6 = exp.variable.base.objects;
              for (k = 0, len2 = ref6.length; k < len2; k++) {
                key = ref6[k];
                switch (key.constructor.name) {
                  case 'Value':
                    this.defs[key.base.value] = _.extend({}, value, {
                      name: key.base.value,
                      exportsProperty: key.base.value,
                      range: [[key.base.locationData.first_line, key.base.locationData.first_column], [key.base.locationData.last_line, key.base.locationData.last_column]]
                    });
                    if (this.defs[key.base.value].type === "import") {
                      if (_.isUndefined(this.modules[this.defs[key.base.value].path])) {
                        this.modules[this.defs[key.base.value].path] = [];
                      }
                      this.modules[this.defs[key.base.value].path].push({
                        name: this.defs[key.base.value].name,
                        range: this.defs[key.base.value].range
                      });
                    }
                    break;
                  case 'Assign':
                    this.defs[key.value.base.value] = _.extend({}, value, {
                      name: key.value.base.value,
                      exportsProperty: key.variable.base.value
                    });
                    return false;
                  default:
                    throw new Error("BUG: Unsupported require Obj structure: " + key.constructor.name);
                }
              }
              break;
            default:
              throw new Error("BUG: Unsupported require structure: " + exp.variable.base.constructor.name);
          }
      }
    };

    Metadata.prototype.visitCode = function(exp) {};

    Metadata.prototype.visitValue = function(exp) {};

    Metadata.prototype.visitCall = function(exp) {};

    Metadata.prototype.visitLiteral = function(exp) {};

    Metadata.prototype.visitObj = function(exp) {};

    Metadata.prototype.visitAccess = function(exp) {};

    Metadata.prototype.visitBlock = function(exp) {};

    Metadata.prototype.visitTry = function(exp) {};

    Metadata.prototype.visitIn = function(exp) {};

    Metadata.prototype.visitExistence = function(exp) {};

    Metadata.prototype.evalComment = function(exp) {
      return {
        type: 'comment',
        doc: exp.comment,
        range: [[exp.locationData.first_line, exp.locationData.first_column], [exp.locationData.last_line, exp.locationData.last_column]]
      };
    };

    Metadata.prototype.evalClass = function(exp) {
      var className, classNode, classProperties, func, i, isClassLevel, j, len, len1, lookedUpVar, name, prototypeExp, prototypeProperties, ref1, ref2, ref3, ref4, reference, subExp, superClassName, value, variable;
      className = exp.variable.base.value;
      superClassName = (ref1 = exp.parent) != null ? ref1.base.value : void 0;
      classProperties = [];
      prototypeProperties = [];
      classNode = _.find(this.classes, function(clazz) {
        return clazz.getFullName() === className;
      });
      ref2 = exp.body.expressions;
      for (i = 0, len = ref2.length; i < len; i++) {
        subExp = ref2[i];
        switch (subExp.constructor.name) {
          case 'Assign':
            value = this["eval"](subExp.value);
            this.defs[className + "." + value.name] = value;
            classProperties.push(value);
            break;
          case 'Value':
            ref3 = subExp.base.properties;
            for (j = 0, len1 = ref3.length; j < len1; j++) {
              prototypeExp = ref3[j];
              switch (prototypeExp.constructor.name) {
                case 'Comment':
                  value = this["eval"](prototypeExp);
                  this.defs[value.range[0][0] + "_line_comment"] = value;
                  break;
                default:
                  isClassLevel = prototypeExp.variable["this"];
                  if (isClassLevel) {
                    name = prototypeExp.variable.properties[0].name.value;
                  } else {
                    name = prototypeExp.variable.base.value;
                  }
                  if (name.reserved) {
                    name = name.slice(0);
                  }
                  value = this["eval"](prototypeExp.value);
                  if (((ref4 = value.constructor) != null ? ref4.name : void 0) === 'Value') {
                    lookedUpVar = this.defs[value.base.value];
                    if (lookedUpVar) {
                      if (lookedUpVar.type === 'import') {
                        value = {
                          name: name,
                          range: [[value.locationData.first_line, value.locationData.first_column], [value.locationData.last_line, value.locationData.last_column]],
                          reference: lookedUpVar
                        };
                      } else {
                        value = _.extend({
                          name: name
                        }, lookedUpVar);
                      }
                    } else {
                      value = {
                        type: 'primitive',
                        name: name,
                        range: [[value.locationData.first_line, value.locationData.first_column], [value.locationData.last_line, value.locationData.last_column]]
                      };
                    }
                  } else {
                    value = _.extend({
                      name: name
                    }, value);
                  }
                  if (isClassLevel) {
                    value.name = name;
                    value.bindingType = "classProperty";
                    this.defs[className + "." + name] = value;
                    classProperties.push(value);
                    if (reference = this.applyReference(prototypeExp)) {
                      this.defs[className + "." + name].reference = {
                        position: reference.range[0]
                      };
                    }
                  } else {
                    value.name = name;
                    value.bindingType = "prototypeProperty";
                    this.defs[className + "::" + name] = value;
                    prototypeProperties.push(value);
                    if (reference = this.applyReference(prototypeExp)) {
                      this.defs[className + "::" + name].reference = {
                        position: reference.range[0]
                      };
                    }
                  }
                  if (value.type === "primitive") {
                    variable = _.find(classNode != null ? classNode.getVariables() : void 0, function(variable) {
                      return variable.name === value.name;
                    });
                    value.doc = variable != null ? variable.doc.comment : void 0;
                  } else if (value.type === "function") {
                    func = _.find(classNode != null ? classNode.getMethods() : void 0, function(method) {
                      return method.name === value.name;
                    });
                    value.doc = func != null ? func.doc.comment : void 0;
                  }
              }
            }
            true;
        }
      }
      return {
        type: 'class',
        name: className,
        superClass: superClassName,
        bindingType: !_.isUndefined(this.bindingTypes[className]) ? this.bindingTypes[className] : void 0,
        classProperties: classProperties,
        prototypeProperties: prototypeProperties,
        doc: classNode != null ? classNode.doc.comment : void 0,
        range: [[exp.locationData.first_line, exp.locationData.first_column], [exp.locationData.last_line, exp.locationData.last_column]]
      };
    };

    Metadata.prototype.evalCode = function(exp) {
      return {
        bindingType: 'variable',
        type: 'function',
        paramNames: _.map(exp.params, (function(param) {
          return param.name.value;
        })),
        range: [[exp.locationData.first_line, exp.locationData.first_column], [exp.locationData.last_line, exp.locationData.last_column]],
        doc: null
      };
    };

    Metadata.prototype.evalValue = function(exp) {
      var ref1;
      if (exp.base) {
        return {
          type: 'primitive',
          name: (ref1 = exp.base) != null ? ref1.value : void 0,
          range: [[exp.locationData.first_line, exp.locationData.first_column], [exp.locationData.last_line, exp.locationData.last_column]]
        };
      } else {
        throw new Error('BUG? Not sure how to evaluate this value if it does not have .base');
      }
    };

    Metadata.prototype.evalCall = function(exp) {
      var moduleName, ref1, ref2, ret, ver;
      if (((ref1 = exp.variable.base) != null ? ref1.value : void 0) === 'require') {
        if (exp.args[0].base == null) {
          return;
        }
        if (!(moduleName = (ref2 = exp.args[0].base) != null ? ref2.value : void 0)) {
          return;
        }
        moduleName = moduleName.substring(1, moduleName.length - 1);
        ver = this.dependencies[moduleName];
        if (ver) {
          moduleName = moduleName + "@" + ver;
        }
        ret = {
          type: 'import',
          range: [[exp.locationData.first_line, exp.locationData.first_column], [exp.locationData.last_line, exp.locationData.last_column]],
          bindingType: 'variable'
        };
        if (/^\./.test(moduleName)) {
          ret.path = moduleName;
        } else {
          ret.module = moduleName;
        }
        if (builtins.indexOf(moduleName) >= 0) {
          ret.builtin = true;
        }
        return ret;
      } else {
        return {
          type: 'function',
          range: [[exp.locationData.first_line, exp.locationData.first_column], [exp.locationData.last_line, exp.locationData.last_column]]
        };
      }
    };

    Metadata.prototype.evalError = function(str, exp) {
      throw new Error("BUG: Not implemented yet: " + str + ". Line " + exp.locationData.first_line);
    };

    Metadata.prototype.evalAssign = function(exp) {
      return this["eval"](exp.value);
    };

    Metadata.prototype.evalLiteral = function(exp) {
      return this.evalError('evalLiteral', exp);
    };

    Metadata.prototype.evalObj = function(exp) {
      return this.evalError('evalObj', exp);
    };

    Metadata.prototype.evalAccess = function(exp) {
      return this.evalError('evalAccess', exp);
    };

    Metadata.prototype.evalUnknown = function(exp) {
      return exp;
    };

    Metadata.prototype.evalIf = function() {
      return this.evalUnknown(arguments);
    };

    Metadata.prototype.visitIf = function() {};

    Metadata.prototype.visitFor = function() {};

    Metadata.prototype.visitParam = function() {};

    Metadata.prototype.visitOp = function() {};

    Metadata.prototype.visitArr = function() {};

    Metadata.prototype.visitNull = function() {};

    Metadata.prototype.visitBool = function() {};

    Metadata.prototype.visitIndex = function() {};

    Metadata.prototype.visitParens = function() {};

    Metadata.prototype.visitReturn = function() {};

    Metadata.prototype.visitUndefined = function() {};

    Metadata.prototype.evalOp = function(exp) {
      return exp;
    };

    Metadata.prototype.applyReference = function(prototypeExp) {
      var i, len, module, ref, ref1, ref2, reference, references;
      ref1 = this.modules;
      for (module in ref1) {
        references = ref1[module];
        for (i = 0, len = references.length; i < len; i++) {
          reference = references[i];
          if ((ref2 = prototypeExp.value.base) != null ? ref2.value : void 0) {
            ref = prototypeExp.value.base.value;
          } else {
            ref = prototypeExp.value.base;
          }
          if (reference.name === ref) {
            return reference;
          }
        }
      }
    };

    return Metadata;

  })();

}).call(this);
