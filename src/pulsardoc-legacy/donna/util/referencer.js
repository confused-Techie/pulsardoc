// Generated by CoffeeScript 1.10.0
(function() {
  var Referencer, _, fs, path;

  _ = require('underscore');

  path = require('path');

  fs = require('fs');

  module.exports = Referencer = (function() {
    function Referencer(classes, mixins, options1) {
      this.classes = classes;
      this.mixins = mixins;
      this.options = options1;
      this.readStandardJSON();
      this.resolveParamReferences();
      this.errors = 0;
    }

    Referencer.prototype.getDirectSubClasses = function(clazz) {
      return _.filter(this.classes, function(cl) {
        return cl.getParentClassName() === clazz.getFullName();
      });
    };

    Referencer.prototype.getInheritedMethods = function(clazz) {
      var parentClass;
      if (!_.isEmpty(clazz.getParentClassName())) {
        parentClass = _.find(this.classes, function(c) {
          return c.getFullName() === clazz.getParentClassName();
        });
        if (parentClass) {
          return _.union(parentClass.getMethods(), this.getInheritedMethods(parentClass));
        } else {
          return [];
        }
      } else {
        return [];
      }
    };

    Referencer.prototype.getIncludedMethods = function(clazz) {
      var i, len, mixin, parentClass, ref1, ref2, result;
      result = {};
      ref2 = ((ref1 = clazz.doc) != null ? ref1.includeMixins : void 0) || [];
      for (i = 0, len = ref2.length; i < len; i++) {
        mixin = ref2[i];
        result[mixin] = this.resolveMixinMethods(mixin);
      }
      if (!_.isEmpty(clazz.getParentClassName())) {
        parentClass = _.find(this.classes, function(c) {
          return c.getFullName() === clazz.getParentClassName();
        });
        if (parentClass) {
          result = _.extend({}, this.getIncludedMethods(parentClass), result);
        }
      }
      return result;
    };

    Referencer.prototype.getExtendedMethods = function(clazz) {
      var i, len, mixin, parentClass, ref1, ref2, result;
      result = {};
      ref2 = ((ref1 = clazz.doc) != null ? ref1.extendMixins : void 0) || [];
      for (i = 0, len = ref2.length; i < len; i++) {
        mixin = ref2[i];
        result[mixin] = this.resolveMixinMethods(mixin);
      }
      if (!_.isEmpty(clazz.getParentClassName())) {
        parentClass = _.find(this.classes, function(c) {
          return c.getFullName() === clazz.getParentClassName();
        });
        if (parentClass) {
          result = _.extend({}, this.getExtendedMethods(parentClass), result);
        }
      }
      return result;
    };

    Referencer.prototype.getConcernMethods = function(clazz) {
      var i, len, mixin, parentClass, ref1, ref2, result;
      result = {};
      ref2 = ((ref1 = clazz.doc) != null ? ref1.concerns : void 0) || [];
      for (i = 0, len = ref2.length; i < len; i++) {
        mixin = ref2[i];
        result[mixin] = this.resolveMixinMethods(mixin);
      }
      if (!_.isEmpty(clazz.getParentClassName())) {
        parentClass = _.find(this.classes, function(c) {
          return c.getFullName() === clazz.getParentClassName();
        });
        if (parentClass) {
          result = _.extend({}, this.getConcernMethods(parentClass), result);
        }
      }
      return result;
    };

    Referencer.prototype.resolveMixinMethods = function(name) {
      var mixin;
      mixin = _.find(this.mixins, function(m) {
        return m.getMixinName() === name;
      });
      if (mixin) {
        return mixin.getMethods();
      } else {
        if (!this.options.quiet) {
          console.log("[WARN] Cannot resolve mixin name " + name);
        }
        this.errors++;
        return [];
      }
    };

    Referencer.prototype.getInheritedVariables = function(clazz) {
      var parentClass;
      if (!_.isEmpty(clazz.getParentClassName())) {
        parentClass = _.find(this.classes, function(c) {
          return c.getFullName() === clazz.getParentClassName();
        });
        if (parentClass) {
          return _.union(parentClass.getVariables(), this.getInheritedVariables(parentClass));
        } else {
          return [];
        }
      } else {
        return [];
      }
    };

    Referencer.prototype.getInheritedConstants = function(clazz) {
      return _.filter(this.getInheritedVariables(clazz), function(v) {
        return v.isConstant();
      });
    };

    Referencer.prototype.getInheritedProperties = function(clazz) {
      var parentClass;
      if (!_.isEmpty(clazz.getParentClassName())) {
        parentClass = _.find(this.classes, function(c) {
          return c.getFullName() === clazz.getParentClassName();
        });
        if (parentClass) {
          return _.union(parentClass.properties, this.getInheritedProperties(parentClass));
        } else {
          return [];
        }
      } else {
        return [];
      }
    };

    Referencer.prototype.linkTypes = function(text, path) {
      var t;
      if (text == null) {
        text = '';
      }
      text = text.split(',');
      text = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = text.length; i < len; i++) {
          t = text[i];
          results.push(this.linkType(t.trim(), path));
        }
        return results;
      }).call(this);
      return text.join(', ');
    };

    Referencer.prototype.linkType = function(text, path) {
      var clazz, i, len, ref1;
      if (text == null) {
        text = '';
      }
      text = _.str.escapeHTML(text);
      ref1 = this.classes;
      for (i = 0, len = ref1.length; i < len; i++) {
        clazz = ref1[i];
        text = text.replace(RegExp("^(" + (clazz.getFullName()) + ")$", "g"), "<a href='" + path + "classes/" + (clazz.getFullName().replace(/\./g, '/')) + ".html'>$1</a>");
        text = text.replace(RegExp("(&lt;|[])(" + (clazz.getFullName()) + ")(&gt;|[,])", "g"), "$1<a href='" + path + "classes/" + (clazz.getFullName().replace(/\./g, '/')) + ".html'>$2</a>$3");
      }
      return text;
    };

    Referencer.prototype.getLink = function(classname, path) {
      var clazz, i, len, ref1;
      ref1 = this.classes;
      for (i = 0, len = ref1.length; i < len; i++) {
        clazz = ref1[i];
        if (classname === clazz.getFullName()) {
          return path + "classes/" + (clazz.getFullName().replace(/\./g, '/')) + ".html";
        }
      }
      return void 0;
    };

    Referencer.prototype.resolveDoc = function(data, entity, path) {
      var example, i, index, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, len8, n, name, note, o, option, options, param, q, r, ref1, ref10, ref11, ref12, ref13, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, returnValue, s, see, throws, todo;
      if (data.doc) {
        if (data.doc.see) {
          ref1 = data.doc.see;
          for (i = 0, len = ref1.length; i < len; i++) {
            see = ref1[i];
            this.resolveSee(see, entity, path);
          }
        }
        if (_.isString(data.doc.abstract)) {
          data.doc.abstract = this.resolveTextReferences(data.doc.abstract, entity, path);
        }
        if (_.isString(data.doc.summary)) {
          data.doc.summary = this.resolveTextReferences(data.doc.summary, entity, path);
        }
        ref2 = data.doc.options;
        for (name in ref2) {
          options = ref2[name];
          if (options == null) {
            continue;
          }
          for (index = j = 0, len1 = options.length; j < len1; index = ++j) {
            option = options[index];
            data.doc.options[name][index].desc = this.resolveTextReferences(option.desc, entity, path);
          }
        }
        ref3 = data.doc.params;
        for (name in ref3) {
          param = ref3[name];
          data.doc.params[name].desc = this.resolveTextReferences(param.desc, entity, path);
          ref5 = (ref4 = param.options) != null ? ref4 : [];
          for (k = 0, len2 = ref5.length; k < len2; k++) {
            option = ref5[k];
            option.desc = this.resolveTextReferences(option.desc, entity, path);
          }
        }
        if (data.doc.notes) {
          ref6 = data.doc.notes;
          for (index = l = 0, len3 = ref6.length; l < len3; index = ++l) {
            note = ref6[index];
            data.doc.notes[index] = this.resolveTextReferences(note, entity, path);
          }
        }
        if (data.doc.todos) {
          ref7 = data.doc.todos;
          for (index = n = 0, len4 = ref7.length; n < len4; index = ++n) {
            todo = ref7[index];
            data.doc.todos[index] = this.resolveTextReferences(todo, entity, path);
          }
        }
        if (data.doc.examples) {
          ref8 = data.doc.examples;
          for (index = o = 0, len5 = ref8.length; o < len5; index = ++o) {
            example = ref8[index];
            data.doc.examples[index].title = this.resolveTextReferences(example.title, entity, path);
          }
        }
        if (_.isString(data.doc.deprecated)) {
          data.doc.deprecated = this.resolveTextReferences(data.doc.deprecated, entity, path);
        }
        if (data.doc.comment) {
          data.doc.comment = this.resolveTextReferences(data.doc.comment, entity, path);
        }
        ref10 = (ref9 = data.doc.returnValue) != null ? ref9 : [];
        for (q = 0, len6 = ref10.length; q < len6; q++) {
          returnValue = ref10[q];
          returnValue.desc = this.resolveTextReferences(returnValue.desc, entity, path);
          ref12 = (ref11 = returnValue.options) != null ? ref11 : [];
          for (r = 0, len7 = ref12.length; r < len7; r++) {
            option = ref12[r];
            option.desc = this.resolveTextReferences(option.desc, entity, path);
          }
        }
        if (data.doc.throwValue) {
          ref13 = data.doc.throwValue;
          for (index = s = 0, len8 = ref13.length; s < len8; index = ++s) {
            throws = ref13[index];
            data.doc.throwValue[index].desc = this.resolveTextReferences(throws.desc, entity, path);
          }
        }
      }
      return data;
    };

    Referencer.prototype.resolveTextReferences = function(text, entity, path) {
      if (text == null) {
        text = '';
      }
      text = text.replace(/`(.|\n)+?`/mg, function(match) {
        return match.replace(/{/mg, "\u0091").replace(/}/mg, "\u0092");
      });
      text = text.replace(/(?:\[((?:\[[^\]]*\]|[^\]]|\](?=[^\[]*\]))*)\])?\{([^\}]+)\}/gm, (function(_this) {
        return function(match, label, link) {
          var href, see;
          link = link.replace(/<.+?>/g, '').split(' ');
          href = link.shift();
          label = _.str.strip(label);
          if (label.length < 2) {
            label = "";
          }
          see = _this.resolveSee({
            reference: href,
            label: label
          }, entity, path);
          if (see.reference) {
            return "<a href='" + see.reference + "'>" + see.label + "</a>";
          } else {
            return match;
          }
        };
      })(this));
      return text = text.replace(/<code(\s+[^>]*)?>(.|\n)+?<\/code>/mg, function(match) {
        return match.replace(/\u0091/mg, '{').replace(/\u0092/mg, '}');
      });
    };

    Referencer.prototype.resolveDelegation = function(origin, ref, entity) {
      var match, methods, otherEntity, refClass, refMethod;
      if (/^\@/.test(ref)) {
        methods = _.map(_.filter(entity.getMethods(), function(m) {
          return _.indexOf(['class', 'mixin'], m.getType()) >= 0;
        }), function(m) {
          return m;
        });
        match = _.find(methods, function(m) {
          return ref.substring(1) === m.getName();
        });
        if (match) {
          if (match.doc.delegation) {
            return this.resolveDelegation(origin, match.doc.delegation, entity);
          } else {
            return [_.clone(match.doc), match.parameters];
          }
        } else {
          if (!this.options.quiet) {
            console.log("[WARN] Cannot resolve delegation to " + ref + " in " + (entity.getFullName()));
          }
          this.errors++;
        }
      } else if (/^\./.test(ref)) {
        methods = _.map(_.filter(entity.getMethods(), function(m) {
          return m.getType() === 'instance';
        }), function(m) {
          return m;
        });
        match = _.find(methods, function(m) {
          return ref.substring(1) === m.getName();
        });
        if (match) {
          if (match.doc.delegation) {
            return this.resolveDelegation(origin, match.doc.delegation, entity);
          } else {
            return [_.clone(match.doc), match.parameters];
          }
        } else {
          if (!this.options.quiet) {
            console.log("[WARN] Cannot resolve delegation to " + ref + " in " + (entity.getFullName()));
          }
          this.errors++;
        }
      } else {
        if (match = /^(.*?)([.@][$a-z_\x7f-\uffff][$\w\x7f-\uffff]*)?$/.exec(ref)) {
          refClass = match[1];
          refMethod = match[2];
          otherEntity = _.find(this.classes, function(c) {
            return c.getFullName() === refClass;
          });
          otherEntity || (otherEntity = _.find(this.mixins, function(c) {
            return c.getFullName() === refClass;
          }));
          if (otherEntity) {
            if (_.isUndefined(refMethod)) {

            } else if (/^\@/.test(refMethod)) {
              methods = _.map(_.filter(otherEntity.getMethods(), function(m) {
                return _.indexOf(['class', 'mixin'], m.getType()) >= 0;
              }), function(m) {
                return m;
              });
              match = _.find(methods, function(m) {
                return refMethod.substring(1) === m.getName();
              });
              if (match) {
                if (match.doc.delegation) {
                  return this.resolveDelegation(origin, match.doc.delegation, otherEntity);
                } else {
                  return [_.clone(match.doc), match.parameters];
                }
              } else {
                if (!this.options.quiet) {
                  console.log("[WARN] Cannot resolve delegation to " + refMethod + " in " + (otherEntity.getFullName()));
                }
                this.errors++;
              }
            } else if (/^\./.test(refMethod)) {
              methods = _.map(_.filter(otherEntity.getMethods(), function(m) {
                return m.getType() === 'instance';
              }), function(m) {
                return m;
              });
              match = _.find(methods, function(m) {
                return refMethod.substring(1) === m.getName();
              });
              if (match) {
                if (match.doc.delegation) {
                  return this.resolveDelegation(origin, match.doc.delegation, otherEntity);
                } else {
                  return [_.clone(match.doc), match.parameters];
                }
              } else {
                if (!this.options.quiet) {
                  console.log("[WARN] Cannot resolve delegation to " + refMethod + " in " + (otherEntity.getFullName()));
                }
                this.errors++;
              }
            }
          } else {
            if (!this.options.quiet) {
              console.log("[WARN] Cannot find delegation to " + ref + " in class " + (entity.getFullName()));
            }
            this.errors++;
          }
        } else {
          if (!this.options.quiet) {
            console.log("[WARN] Cannot resolve delegation to " + ref + " in class " + (otherEntity.getFullName()));
          }
          this.errors++;
        }
      }
      return [origin.doc, origin.parameters];
    };

    Referencer.prototype.resolveSee = function(see, entity, path) {
      var instanceMethods, match, methods, otherEntity, ref, refClass, refMethod;
      if (see.reference.substring(0, 1) === ' ') {
        return see;
      }
      ref = see.reference;
      if (/^\./.test(ref)) {
        methods = _.map(_.filter(entity.getMethods(), function(m) {
          return _.indexOf(['class', 'mixin'], m.getType()) >= 0;
        }), function(m) {
          return m.getName();
        });
        if (_.include(methods, ref.substring(1))) {
          see.reference = "" + path + (entity.constructor.name === 'Class' ? 'classes' : 'modules') + "/" + (entity.getFullName().replace(/\./g, '/')) + ".html#" + (ref.substring(1)) + "-class";
          if (!see.label) {
            see.label = ref;
          }
        } else {
          see.label = see.reference;
          see.reference = void 0;
          if (!this.options.quiet) {
            console.log("[WARN] Cannot resolve link to " + ref + " in " + (entity.getFullName()));
          }
          this.errors++;
        }
      } else if (/^::/.test(ref)) {
        instanceMethods = _.map(_.filter(entity.getMethods(), function(m) {
          return m.getType() === 'instance';
        }), function(m) {
          return m.getName();
        });
        if (_.include(instanceMethods, ref.substring(2))) {
          see.reference = path + "classes/" + (entity.getFullName().replace(/\./g, '/')) + ".html#" + (ref.substring(2)) + "-instance";
          if (!see.label) {
            see.label = ref;
          }
        } else {
          see.label = see.reference;
          see.reference = void 0;
          if (!this.options.quiet) {
            console.log("[WARN] Cannot resolve link to " + ref + " in class " + (entity.getFullName()));
          }
          this.errors++;
        }
      } else {
        if (!/^https?:\/\//.test(ref)) {
          if (match = /^(.*?)((\.|::)[$a-z_\x7f-\uffff][$\w\x7f-\uffff]*)?$/.exec(ref)) {
            refClass = match[1];
            refMethod = match[2];
            otherEntity = _.find(this.classes, function(c) {
              return c.getFullName() === refClass;
            });
            otherEntity || (otherEntity = _.find(this.mixins, function(c) {
              return c.getFullName() === refClass;
            }));
            if (otherEntity) {
              if (_.isUndefined(refMethod)) {
                if (_.include(_.map(this.classes, function(c) {
                  return c.getFullName();
                }), refClass) || _.include(_.map(this.mixins, function(c) {
                  return c.getFullName();
                }), refClass)) {
                  see.reference = "" + path + (otherEntity.constructor.name === 'Class' ? 'classes' : 'modules') + "/" + (refClass.replace(/\./g, '/')) + ".html";
                  if (!see.label) {
                    see.label = ref;
                  }
                } else {
                  see.label = see.reference;
                  see.reference = void 0;
                  if (!this.options.quiet) {
                    console.log("[WARN] Cannot resolve link to entity " + refClass + " in " + (entity.getFullName()));
                  }
                  this.errors++;
                }
              } else if (/^\./.test(refMethod)) {
                methods = _.map(_.filter(otherEntity.getMethods(), function(m) {
                  return _.indexOf(['class', 'mixin'], m.getType()) >= 0;
                }), function(m) {
                  return m.getName();
                });
                if (_.include(methods, refMethod.substring(1))) {
                  see.reference = "" + path + (otherEntity.constructor.name === 'Class' ? 'classes' : 'modules') + "/" + (otherEntity.getFullName().replace(/\./g, '/')) + ".html#" + (refMethod.substring(1)) + "-class";
                  if (!see.label) {
                    see.label = ref;
                  }
                } else {
                  see.label = see.reference;
                  see.reference = void 0;
                  if (!this.options.quiet) {
                    console.log("[WARN] Cannot resolve link to " + refMethod + " of class " + (otherEntity.getFullName()) + " in class " + (entity.getFullName()));
                  }
                  this.errors++;
                }
              } else if (/^::/.test(refMethod)) {
                instanceMethods = _.map(_.filter(otherEntity.getMethods(), function(m) {
                  return _.indexOf(['instance', 'mixin'], m.getType()) >= 0;
                }), function(m) {
                  return m.getName();
                });
                if (_.include(instanceMethods, refMethod.substring(2))) {
                  see.reference = "" + path + (otherEntity.constructor.name === 'Class' ? 'classes' : 'modules') + "/" + (otherEntity.getFullName().replace(/\./g, '/')) + ".html#" + (refMethod.substring(2)) + "-instance";
                  if (!see.label) {
                    see.label = ref;
                  }
                } else {
                  see.label = see.reference;
                  see.reference = void 0;
                  if (!this.options.quiet) {
                    console.log("[WARN] Cannot resolve link to " + refMethod + " of class " + (otherEntity.getFullName()) + " in class " + (entity.getFullName()));
                  }
                  this.errors++;
                }
              }
            } else {
              if (this.verifyExternalObjReference(see.reference)) {
                if (!see.label) {
                  see.label = see.reference;
                }
                see.reference = this.standardObjs[see.reference];
              } else {
                see.label = see.reference;
                see.reference = void 0;
                if (!this.options.quiet) {
                  console.log("[WARN] Cannot find referenced class " + refClass + " in class " + (entity.getFullName()) + " (" + see.label + ")");
                }
                this.errors++;
              }
            }
          } else {
            see.label = see.reference;
            see.reference = void 0;
            if (!this.options.quiet) {
              console.log("[WARN] Cannot resolve link to " + ref + " in class " + (entity.getFullName()));
            }
            this.errors++;
          }
        }
      }
      return see;
    };

    Referencer.getLinkMatch = function(text) {
      var m;
      if (m = text.match(/\{([\w.]+)\}/)) {
        return m[1];
      } else {
        return "";
      }
    };

    Referencer.prototype.readStandardJSON = function() {
      return this.standardObjs = JSON.parse(fs.readFileSync(path.join(__dirname, 'standardObjs.json'), 'utf-8'));
    };

    Referencer.prototype.verifyExternalObjReference = function(name) {
      return this.standardObjs[name] !== void 0;
    };

    Referencer.prototype.resolveParamReferences = function() {
      var copyParam, entities, entity, i, len, method, name, names, otherEntity, otherMethod, otherMethodType, param, ref, refMethod, results;
      entities = _.union(this.classes, this.mixins);
      results = [];
      for (i = 0, len = entities.length; i < len; i++) {
        entity = entities[i];
        results.push((function() {
          var j, len1, ref1, results1;
          ref1 = entity.getMethods();
          results1 = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            method = ref1[j];
            if (method.getDoc() && !_.isEmpty(method.getDoc().params)) {
              results1.push((function() {
                var base, base1, base2, k, len2, ref2, results2;
                ref2 = method.getDoc().params;
                results2 = [];
                for (k = 0, len2 = ref2.length; k < len2; k++) {
                  param = ref2[k];
                  if (param.reference) {
                    if (ref = /([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)([#.])([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)/i.test(param.reference)) {
                      otherEntity = _.first(entities, function(e) {
                        return e.getFullName() === ref[1];
                      });
                      otherMethodType = ref[2] === '.' ? ['instance'] : ['class', 'mixin'];
                      otherMethod = ref[3];
                    } else {
                      otherEntity = entity;
                      otherMethodType = param.reference.substring(0, 1) === '.' ? ['instance', 'mixin'] : ['class', 'mixin'];
                      otherMethod = param.reference.substring(1);
                    }
                    refMethod = _.find(otherEntity.getMethods(), function(m) {
                      return m.getName() === otherMethod && _.indexOf(otherMethodType, m.getType()) >= 0;
                    });
                    if (refMethod) {
                      if (param.name) {
                        copyParam = _.find(refMethod.getDoc().params, function(p) {
                          return p.name === param.name;
                        });
                        if (copyParam) {
                          (base = method.getDoc()).params || (base.params = []);
                          method.getDoc().params = _.reject(method.getDoc().params, function(p) {
                            return p.name = param.name;
                          });
                          method.getDoc().params.push(copyParam);
                          if (_.isObject(refMethod.getDoc().paramsOptions)) {
                            (base1 = method.getDoc()).paramsOptions || (base1.paramsOptions = {});
                            results2.push(method.getDoc().paramsOptions[param.name] = refMethod.getDoc().paramsOptions[param.name]);
                          } else {
                            results2.push(void 0);
                          }
                        } else {
                          if (!this.options.quiet) {
                            console.log("[WARN] Parameter " + param.name + " does not exist in " + param.reference + " in class " + (entity.getFullName()));
                          }
                          results2.push(this.errors++);
                        }
                      } else {
                        names = _.map(method.getParameters(), function(p) {
                          return p.getName();
                        });
                        method.getDoc().params = _.filter(refMethod.getDoc().params, function(p) {
                          return _.contains(names, p.name);
                        });
                        if (_.isObject(refMethod.getDoc().paramsOptions)) {
                          (base2 = method.getDoc()).paramsOptions || (base2.paramsOptions = {});
                          results2.push((function() {
                            var l, len3, results3;
                            results3 = [];
                            for (l = 0, len3 = names.length; l < len3; l++) {
                              name = names[l];
                              results3.push(method.getDoc().paramsOptions[name] = refMethod.getDoc().paramsOptions[name]);
                            }
                            return results3;
                          })());
                        } else {
                          results2.push(void 0);
                        }
                      }
                    } else {
                      if (!this.options.quiet) {
                        console.log("[WARN] Cannot resolve reference tag " + param.reference + " in class " + (entity.getFullName()));
                      }
                      results2.push(this.errors++);
                    }
                  } else {
                    results2.push(void 0);
                  }
                }
                return results2;
              }).call(this));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    return Referencer;

  })();

}).call(this);
